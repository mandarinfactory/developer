<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./style.css" />
    <script src="./apps01.js"></script>
    <title>JS초중급01</title>
  </head>
  <body>
    <div class="one">
      <ul>
        <h2>1.생성자함수</h2>
        <li>생성자함수는 보통 첫글자를 대문자로 쓰는편이다.</li>
      </ul>
    </div>
    <div class="two">
      <ul>
        <h2>2.객체(object)method, 계산된 프로퍼티(computed property)</h2>
        <li>01.계산된 프로퍼티(computed property)</li>
        <ul>
          <li>
            let a = 'age'; <br />
            const user = { <br />
            name : 'Brent', <br />
            age가 아닌 [a] : 30 --> 계산된 프로퍼티라고 한다. <br />
            }
          </li>
        </ul>
        <li>
          02. method들(assign, keys, values, entries, fromEntries)
          <ul>
            <li>
              - Object.assign() : 객체 복제 <br />
              const user = { <br />
              name : 'John', <br />
              age : 31 <br />
              } <br />
              const cloneUser = user만 했다고 user가 정말 clone된게 아니다!
              <br />
              user, cloneUser둘다 그냥 화살표로 같은곳을 향하고 있는 의미이다!
              <br />
              const cloneUser = Object.assign({}, user); 꼴로 써야 객체가 복제가
              된다. <br />
              여기서 빈객체({})는 초기값을 말한다. <br />
              빈객체가 아닌 같은 index를 가지고 있다면 덮어쓰기가 되서 복제되는
              객체의 값으로 변경된다.
            </li>
          </ul>
        </li>
        <li>
          - Object.keys() : 키 배열 반환 / values() : 값 배열 반환<br />
          const user = { <br />
          name : 'Mike',<br />
          age : 30,<br />
          gender : 'male'<br />
          }<br />
          Object.keys(user); Object.values(user);
        </li>
        <li>
          - Object.entries() : 키/값 모두 배열 반환 - Object.fromEntries() :
          키/값 배열을 모두 객체로 반환
        </li>
      </ul>
    </div>
    <div class="three">
      <ul>
        <h2>3.심볼(Symbol)</h2>
        <li>
            symbol은 유일한 식별자를 만들때 쓰인다. <br>
            symbol은 property key로 사용할 수 있다.
            symbol은 유일성이 보장된다. --> 전체의 코드 중 딱 하나이다! <br> 
            const a = Symbol(); // new를 붙이지 않는다! <br>
            const b = Symbol(); <br>
            같아 보일지라도 a === b, a ==b 둘다 false로 출력된다. <br>
            id.description을 사용해야 기본 Symbol 메소드는 이름을 얻을수 있다. <br>
            Symbol은 Object.keys/values등으로 나오지 않고, 따로 Object.getOwnPropertySymbols()를 써줘야한다. <br>
            또는, Reflect.ownKeys()를 사용하면 Symbol을 포함한 모든 index를 보여준다.
        </li>
        <li>
            Symbol.for --> 전역 심볼이다. <br>
            하나의 심볼만 보장받을 수 있다. <br>
            없으면 만들고, 있으면 가져와야하기 때문이다. <br>
            Symbol 함수는 매번 다른 Symbol값을 생성하지만, <br>
            Symbol.for 메소드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유한다. <br>
            const id1 = Symbol.for('id') <br>
            const id2 = Symbol.for('id') <br>
            id1 === id2 // true로 출력한다. <br>
            또한, 이름을 얻고싶다면 Symbol.keyFor(id1)을 하면 'id'가 출력된다.
        </li>
      </ul>
    </div>
    <div class="four">
      <ul>
        <h2>4.Number, Math</h2>
        <li>
          toString()은 문자로 변환해주는데 ()안에 2/16를 넣으면 2/16진법으로 변경시켜준다. <br>
          let num = 10; <br>
          num.toString(2); // 1010 <br>
          let num21 = 256; <br>
          num2.toString(16); // ff <br>
        </li>
        <li>
          Math와 연결된 메소드들이 있다. <br>
          Math.ceil() --> 올림 <br>
          let num1 = 5.128, Math.ceil(num1) = 6 <br>
          Math.floor() --> 내림 <br>
          Math.round() --> 반올림 <br>
          만약, 소수점 둘째자리까지 표현해야한다면? <br>
          let average = 30.2589; <br>
          Math.round(average * 100)/100 --> 처음에 100을 곱해서 반올림후 다시 100으로 나눠주면 값이 나온다. // 30.12 <br>
          또는, toFixed()를 사용해준다. --> average.toFixed(2) // 30.12
        </li>
        <li>
          isNaN --> NaN인지 아닌지 판별해준다. <br>
          let x = Number('x') // NaN <br>
          그냥 NaN == NaN / NaN === NaN을 하면 둘다 false로 출력되고 오직 isNaN()으로만 확인할 수 있다. <br>
          따라서 isNaN(3) // false, isNaN(x) //true
        </li>
        <li>
          parseInt() --> string을 number로 바꿔준다(정수만). 문자로 혼용되어있는 숫자도 숫자만 변경시켜준다.<br>
          단, 숫자로 시작하지 않으면 NaN을 출력한다. (f3, color123등) <br>
          let margin = '10px'; <br>
          parseInt(margin) // 10, Number(margin) // NaN
        </li>
        <li>
          parseFloat() --> 정수랑 소수점까지 같이 Number로 변환해준다.
        </li>
        <li>
          Math.random() --> 0 ~ 1 사이 무작위 숫자를 생성한다.
        </li>
        <li>
          Math.max() / min() --> 각각 최대값, 최솟값을 보여준다.
        </li>
        <li>
           Math.abs() --> 절대값을 보여준다. Math.abs(-1) // 1
        </li>
        <li>
          Math.pow(n, m)  --> 제곱을 보여준다. Math.pow(2, 10) // 1024 <br>
          Math.sqrt() --> 제곱근을 보여준다. Math.sqrt(16) // 4
        </li>
      </ul>
    </div>
    <div class="five">
      <ul>
        <h2>5.String</h2>
        <li>
          ``(백틱)은 여러줄을 쓸때 편리하다. enter를 치고 계속 쓸수 있다.
        </li>
        <li>
          문자도 숫자처럼 비교를 할 수 있다. a ==> z로 갈수록 커지고, 대문자보다 소문자가 더 크다.
        </li>
        <li>
          length를 통해 문자열 길이를 알수 있다. <br>
          let desc = 'hello.' // desc.length = 6 <br>
          desc[0] // 'h'
        </li>
        <li>
          toUpperCase()/toLowerCase() <br>
          UpperCase는 모든 알파벳을 대문자로, LowerCase()는 소문자로 변경시켜준다.
        </li>
        <li>
          indexOf() --> 문자를 인수로 받아 몇번째에 위치하는지 알려준다. (띄어쓰기포함해서의 위치)
          let desc = 'Hi guys. Nice to meet you.' <br>
          desc.indexOf('to') // 14 <br>
          만약, 찾는 문자가 없으면 -1을 출력한다. <br>
          찾는문자의 장단에 상관없이 첫번째 문자의 위치만 알려준다.
        </li>
        <li>
          string.slice(n,m) --> n부터 m까지의 문자만 출력한다. <br>
          단, m이 없으면 문자열 끝까지, 양수이면 그 숫자까지(포함하지는 않음) 음수이면 끝에서부터 셈을 한다. <br>
          let desc = 'abcdefg';
          desc.slice(2) // 'cdefg';
          desc.slice(0,5) // 'abcde';
          desc.slice(2,-2) // 'cde';
        </li>
        <li>
          string.substring(n, m) --> slice와 비슷하게 동작하며, n과 m을 바꿔도 동작한다. (그냥 n과 m사이라고 생각하면 된다.)<br>
          음수를 허용하지 않고 0으로 인식한다. <br>
          let desc = 'abcdefg'; <br>
          desc.substring(2, 5)// 'cde' <br>
          desc.substring(5, 2)// 'cde'
        </li>
        <li>
          string.substr(n, m) --> n부터 시작해서 m를 가져온다. <br>
          let desc = 'abcdefg'; <br>
          desc.substr(2,4) // 'cdef'
          desc.substr(-4, 2) // 'de'
        </li>
        <li>
          string.trim() --> 앞, 뒤 공백을 제거해준다. <br>
          string.repeat(n) --> string을 n번 반복시켜준다. <br>
        </li>
      </ul>
    </div>
  </body>
</html>
