<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./style.css" />
    <script src="./apps01.js"></script>
    <title>JS초중급02</title>
</head>
<body>
    <div class="six">
        <ul>
            <h2>6.배열(array)</h2>
            <li>
                array.splice(n, m) --> 배열의 특정 요소를 지워준다. n번째부터 시작해서 m개를 지운다. <br>
                단, 여기서 m이 0이면 아무것도 지워지지 않는다. <br>
                let arr = [1,2,3,4,5]; <br>
                arr.splice(1,2); <br>
                console.log(arr); // [1,4,5] <br>
                array.splice(n, m, x) --> 특성요소를 지우고 x 추가<br>
                let arr = [1,2,3,4,5]; <br>
                arr.splice(1,3,100,200); <br>
                console.log(arr); // [1,100,200,5] <br>
                splice로 삭제된 요소는 새로운 배열로 반환할수 있다. <br>
                let arr = [1,2,3,4,5] <br>
                let cut = arr.splice(1, 3); <br>
                console.log(cut) // [2,3,4,5]
            </li>
            <li>
                array.slice(n, m) --> n부터 m까지 반환 <br>
                let arr = [1,2,3,4,5]; <br>
                arr.slice(1,4) // [2,3,4] <br>
                arr.slice() --> ()내에 아무것도 없다면, 배열이 복사가 된다.
            </li>
            <li>
                array.concat(arr2, arr3 ···) --> ()내의 모든 배열을 합쳐서 새배열로 반환한다. <br>
                let arr = [1,2]; <br>
                arr.concat([3,4]); // [1,2,3,4] <br>
                arr.concat([3,4],5,6); // [1,2,3,4,5,6] <br>
            </li>
            <li>
                array.forEach(function(){}) : 배열의 반복 <br>
                let users = ['Mike', 'Tom', "Jane"]; <br>
                users.forEach((item(해당배열내요소), index(0,1,2···), arr(해당배열)) => { <br>
                    //.... <br>
                }) <br>
            </li>
            <li>
                arr.indexOf / arr.lastIndexOf / arr.includes<br>
                let arr = [1,2,3,4,5,1,2,3] <br>
                arr.indexOf(3); // 2 <br>
                arr.indexOf(3,3) // 7 인자가 두개이면 뒤에있는 인자를 기준으로 출력한다. <br>
                arr.lastIndexOf(3); // 7 --> lastIndexOf는 끝에서부터 확인해서 출력해준다. <br>
                arr.includs(1) // true, arr.includes(8) // false --> 해당 인자가 있는지 없는지만 확인할수 있다. <br>
                추가적으로 find()/findIndex() 또한 includes와 동일한 기능이지만 ()내에 fn을 넣어 다양한 값을 출력시키도록 할 수 있다. (짝수라던가 등등..) <br>
                단, find()/findIndex()는 첫번째 true값만 반환하고 끝, 없으면 undefined를 반환한다. <br>
            </li>
            <li>arr.filter(fn) --> 만족하는 모든 요소를 배열로 반환한다.</li>
            <li>arr.reverse() : 역순으로 재정렬 let arr = [1,2,3] arr.reverse() // [3,2,1]</li>
            <li>
                arr.map(fn) --> 함수를 받아 특정기능을 시행하고 새로운 배열을 반환한다.
            </li>
        </ul>
    </div>
    <div class="seven">
        <ul>
            <h2>7.arr.sort(), arr.reduce()</h2>
            <li>arr.sort() --> 배열을 재정렬 시킨다. 배열 자체가 변경되니 주의할것</li>
            <li>
                arr.reduce(fn) : 인수로 함수를 받음 <br>
                (누적계산값, 현재값) => { return 계산값 };
            </li>
        </ul>
    </div>
    <div class="eight">
        <ul>
            <h2>8.구조분해할당(Destructuring assignment)</h2>
            <li>구조분해할당 구문은 배열이나 객체의 속성을 분해해서 그 값을 변수에 담을 수 있게 하는 표현식이다.</li>
            <li>
                let [x, y] = [1, 2]; <br>
                console.log(x); // 1 <br>
                console.log(y); // 2 <br>
            </li>
        </ul>
    </div>
    <div class="nine">
        <ul>
            <h2>9.나머지 매개변수, 전개 구문(Rest parameters, Spread syntax)</h2>
            <li>
                function showName (name) { <br>
                    console.log(name); <br>
                } <br>
                showName('Mike'); // Mike <br>
                만약 여기서 이름을 두개를 전달하면? <br>
                showName('Mike', 'Tom'); // Mike만 찍힘
            </li>
            <li>
                01. arguments
                <ul>
                    <li>함수로 넘어 온 모든 인수에 접근할 수 있다.</li>
                    <li>함수내에서 이용 가능한 지역 변수</li>
                    <li>length / index</li>
                    <li>array 형태의 객체</li>
                    <li>배열의 내장 메서드가 없음(forEach, map)</li>
                </ul>
            </li>
            <li>
                02. 나머지 매개변수(Rest parameters)
                <ul>
                    <li>정해지지않은 갯수의 인수를 배열로 나타낼수 있게 해준다.</li>
                </ul>
            </li>
        </ul>
    </div>
    <div class="ten">
        <ul>
            <h2>10.Closure</h2>
            <li>JS는 어휘적환경(Lexical Environment)을 갖는다.
                <ul>
                    <li>코드를 실행하면 스크립트 내에서 먼저 선언된 변수들이 전역 Lexical 환경으로 올라간다.</li>
                    <li>선언한 변수는 아직 초기화가 안됐지만, 함수는 이미 Lex.환경에서부터 초기화가 되어있어 사용가능하다.</li>
                    <li>
                        Closure --> 함수와 lexical 환경의 조합, 함수가 생성될 당시의 외부 변수를 기억해서 생성 이후에도 계속 접근 가능하게 한다.
                    </li>
                </ul>
            </li>
        </ul>
    </div>
</body>
</html>