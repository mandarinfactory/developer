<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100;300;400;500;700;900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="./style.css" />
    <script src="./apps.js"></script>
    <title>JS초중급02</title>
</head>
<body>
    <div class="six">
        <ul>
            <h2>6.배열(array)</h2>
            <li>
                array.splice(n, m) --> 배열의 특정 요소를 지워준다. n번째부터 시작해서 m개를 지운다. <br>
                단, 여기서 m이 0이면 아무것도 지워지지 않는다. <br>
                let arr = [1,2,3,4,5]; <br>
                arr.splice(1,2); <br>
                console.log(arr); // [1,4,5] <br>
                array.splice(n, m, x) --> 특성요소를 지우고 x 추가<br>
                let arr = [1,2,3,4,5]; <br>
                arr.splice(1,3,100,200); <br>
                console.log(arr); // [1,100,200,5] <br>
                splice로 삭제된 요소는 새로운 배열로 반환할수 있다. <br>
                let arr = [1,2,3,4,5] <br>
                let cut = arr.splice(1, 3); <br>
                console.log(cut) // [2,3,4,5]
            </li>
            <li>
                array.slice(n, m) --> n부터 m까지 반환 <br>
                let arr = [1,2,3,4,5]; <br>
                arr.slice(1,4) // [2,3,4] <br>
                arr.slice() --> ()내에 아무것도 없다면, 배열이 복사가 된다.
            </li>
            <li>
                array.concat(arr2, arr3 ···) --> ()내의 모든 배열을 합쳐서 새배열로 반환한다. <br>
                let arr = [1,2]; <br>
                arr.concat([3,4]); // [1,2,3,4] <br>
                arr.concat([3,4],5,6); // [1,2,3,4,5,6] <br>
            </li>
            <li>
                array.forEach(function(){}) : 배열의 반복 <br>
                let users = ['Mike', 'Tom', "Jane"]; <br>
                users.forEach((item(해당배열내요소), index(0,1,2···), arr(해당배열)) => { <br>
                    //.... <br>
                }) <br>
            </li>
            <li>
                arr.indexOf / arr.lastIndexOf / arr.includes<br>
                let arr = [1,2,3,4,5,1,2,3] <br>
                arr.indexOf(3); // 2 <br>
                arr.indexOf(3,3) // 7 인자가 두개이면 뒤에있는 인자를 기준으로 출력한다. <br>
                arr.lastIndexOf(3); // 7 --> lastIndexOf는 끝에서부터 확인해서 출력해준다. <br>
                arr.includs(1) // true, arr.includes(8) // false --> 해당 인자가 있는지 없는지만 확인할수 있다. <br>
                추가적으로 find()/findIndex() 또한 includes와 동일한 기능이지만 ()내에 fn을 넣어 다양한 값을 출력시키도록 할 수 있다. (짝수라던가 등등..) <br>
                단, find()/findIndex()는 첫번째 true값만 반환하고 끝, 없으면 undefined를 반환한다. <br>
            </li>
            <li>arr.filter(fn) --> 만족하는 모든 요소를 배열로 반환한다.</li>
            <li>arr.reverse() : 역순으로 재정렬 let arr = [1,2,3] arr.reverse() // [3,2,1]</li>
            <li>
                arr.map(fn) --> 함수를 받아 특정기능을 시행하고 새로운 배열을 반환한다.
            </li>
        </ul>
    </div>
</body>
</html>