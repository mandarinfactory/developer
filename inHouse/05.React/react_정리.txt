1. Destructuring 문법

    - let num = [1,2]
    let a = num[0]; // 1
    let b = num[1]; // 2

    let [a, b] = [1, 2] // a = 1. b = 2  --> 이런꼴로 만드는걸 Destructuring문법이라고 한다.

2. useState 

    < useState를 왜쓰는가? >

        - 변동시 자동으로 HTML에 반영되게 만들고 싶을때 쓴다.
        - 다시말해, 자주변경될거 같은 HTML부분은 state로 만든다.
        - 자주변경할 필요가 없는 HTML들은 하드코딩을 하는게 낫다.

    < state변경함수의 특징 >

        - 기존state == 변경state라면 바꿔주지 않는다.
        let [state, setState] = useState('hello');
        <div onClick = {() => {
            setState(state)
        }}>{state}</div> ---> 이꼴이면 변경하지 않는다. 어처피 'hello'인건 같으니까(자동으로 절약시켜줌)
        - state변경함수는 늦게 처리 되게 된다.

    < array/object 특징 >

        - array/object 담은 변수엔 화살표만 저장된다.
        let arr = [1,2,3]
        일때, let arr가 [1,2,3]이 아니고 [1,2,3]이 어디에 있는지(RAM의 어디에 위치해 있는지)를 
        가리키는 화살표이다.
        - 따라서. arr[0] = 4라고 하면 array 자체는 수정했지만 변수arr에 있던 화살표는 수정이 되지 않았다.
        - useState도 기존==변경이 다른점이 없다고 인식하게 되므로 변경해주지 않는다.
        - 만약, let copy = arr라고 하더라도, 화살표만 copy한거기 때문에 결과는 같다.
        - [...arr]으로 쓰게 되면 화살표를 아예 새로 바꿔달라라는 말이다. === 완전히 독립적인 array
        - useState도 새로운 arr로 인식한다. (object도 똑같이 해당함.)
        - array값을 변경할 때에는 객체와 마찬가지로, 불변성을 지켜줘야한다. --> push, splice, sort등의 함수를 사용시에는 copy후 사용해야한다.
        - 불변성을 지키면서 배열에 새 항목을 추가하는 방법은 spread연산자를 사용하거나, concat함수를 사용하는 것이다.
        
            1. spread연산자를 사용하기 
                - 기존의 배열을 수정하지 않고, 새로운 원소가 추가된 새로운 배열을 만들어준다. ...users를 통해 기존배열을
                복사해서 새배열을 생성한다.
                    setUsers([..users, user])
            
            2. concat함수 사용하기
                - concat도 기존의 배열을 수정하지 않고, 새로운 원소가 추가된 새로운 배열을 만들어준다. 
                여러개의 배열을 하나의 배열로 합칠 때 사용한다. concat뒤에 값은 배열이 아닌 값도 넣을 수 있다.
                    setUsers(users,concat(user))

 3. Component

    - Component는 일종의 UI 조각이라고 생각하면 되고, 쉽게 재사용도 할 수 있다.
    - React에서는 불변성을 지켜줘야하만 Component 업데이트 성능 최적화를 제대로 할 수 있다.
    < Component는 언제 사용하는건가? >

        - 반복적인 HTML을 축약할때
        - 큰 page들
        - 자주변경되는 HTML들
        - 단, state를 가져다쓸 때 문제가 생긴다. --> 각각 Comp들마다 다른 function들이므로 쓰기가 번거로움.
        따라서, Comp를 너무 남용하는것도 좋지는 않다.

    < 동적인 UI 만드는 step! >

        1. HTML, CSS로 미리 design 완성하기
        2. UI의 현재 상태를 useState로 저장하기
        3. state에 따라 UI가 어떻게 보일지 작성하기(조건문등으로)
        └-> React에서는 버튼을 누르면 modal창 스위치(state)만 건드림(직접 HTML은 안건드림!) 
            JS는 modal창의 HTML 직접 건드림

4. map

- map() 사용법
[1,2,3].map(() => {})
    1. array의 자료 갯수만큼 callback함수안의 코드를 실행해줌

    2. 함수의 파라미터는 array안에 있던 자료임
        [1,2,3].map(a => {
            console.log(a);
        }) // 1, 2, 3이 순차적으로 출력된다.

    3. return에 뭐 적으면 자료 갯수만큼 array로 담아줌
        [1,2,3].map(() => {
            return '1234';
        }) // ['1234','1234','1234']
        
    4. map()함수
        - 써있는 왼쪽 array 자료만큼 내부코드를 실행시켜줌
        - return 오른쪽에 있는걸 array로 담아줌
        - 유용한 parameter 2개 사용가능 (a, b)
            -> a : array안에 있던 자료들을 뜻함
            -> b : array안에 있던 자료들의 번호를 뜻함(0,1,2···)
        - 반복문으로 HTML을 생성하게 되면 React에서는 'key={HTML마다 다른숫자}'로 선택자를 추가해줘야한다.

5. props(proporties) 

    - 어떠한 값을 comp에게 전달해줘야 할 때, props를 사용한다.
    - 부모state ---> 자식state은 가능하지만 자식간의 또는 자식state ---> 부모state로는 이동이 가능하지 않다.
    - 부모state ---> 자식state 전송하는법

        1. <자식 Comp 작명(대부분state이름으로함)={state이름} />
        2. props 파라미터 등록 후 props.작명 사용

6. input 

    - React에서는 항상 HTML 요소를 열었으면 닫아줘야한다. <></>
    - input에서 뭔가 입력시 코드를 실행하고 싶으면 --> onChange, onInput으로 event-handler(onClick, onChange···)를 써주면 된다.

7. export---import

    - export하려면 export하려는 해당 file에 'export default 변수명'으로 써주면 된다.(변수, 함수든 export 가능하다!)
        └-> 여려개 하려면 export { 변수1, 변수2}로 써주면 된다.
    - import는 import 작명 from 'export하는 해당 파일 경로'로 써주면 된다.
        └-> 여러개로 받았다면 import { 변수1, 변수2 } from '해당경로'로 써주면 된다.

8. react-router

    - router hooks : useNavigate(), Outlet
    - useNavigate() --> 페이지 이동을 도와준다.

9. get-parameter(useParams())

    - useParams() --> 현재 /:url 파라미터 자리에 유저가 입력한 값을 가져올 수 있다. && 파라미터는 몇번이고 사용가능하다. (/:xx/:xx)

10. Component의 Life-cycle(생명주기)

    1. Comp가 실행되는 순간 --> 페이지에 장착됐다고 한다. (mount) / 업데이트 (update) / 제거 (unmount)
    2. Comp의 생명주기를 알면 dev가 중간중간 간섭이 가능하다.(코드실행)

    - useEffect를 쓰는 이유

        1. HTML랜더링이 되고 나서 useEffect내에 있는 함수가 작동한다.
        2. 어려운 연산, 서버에서 데이터 가져오는 작업, 타이머 장착하는것(setInterval, setTimeout) --> useEffect안에 넣음!
        3. 왜 Effect? --> side Effect(함수의 핵심기능과 상관없는 부가기능)에서 따온 이름이다. HTML랜더링 기능이 아닌 외의 기능이므로!
        4. useEffect 뒤에 '[]'의 뜻은 []안에 들어간 state가 변할때만 실행되게 해준다.
        └-> 그냥 '[]'로만 쓰면 mount에만 실행된다. (딱1번만)
        5. Effect안에 return () => {}를 넣으면  return이 useEffect동작전에 실행된다. ==> return안에 기존 데이터요청 삭제를 넣는편이다.
        <정리>

            - useEffect(() => {}) --> 재랜더링마다 코드실행하고 싶으면 사용
            - useEffect(() => {}, []) --> mount시 1회만 코드실행하고 싶으면 사용
            - useEffect(() => {
                 return () => {

                 }
            }, []) --> unmount시 1회만 코드실행하고 싶으면 사용
            - useEffect 실행 전에 뭔가 실행하려면 언제나! return () => {}를 사용해아한다.

11. AJAX

    - 서버(어떤 데이터를 부탁하면 보내주는 프로그램)에 AJAX를 사용해서 데이터를 요청하는것
    - 데이터 가져올때는 GET, 데이터를 보낼때는 POST를 사용한다.


12. localStorage

    - data를 서버로 보내서 DB에 영구저장하면 지워지지 않고 브라우저가 렌더링이 되더라도 계속 남는다.
    - 따로 브라우저마다 localStorage라고 서버처럼 쓰일수 있는 저장소가 있다. (문자만 가능, 최대 5MB --> 반영구적 저장가능)
    - LocalStorage : 재접속하더라도 계속해서 남는다. / SessionStorage : 브라우저를 끄면 저장되어 있던 data도 날라간다.
        
        1. localStorage.setItem('key', 'value') --> 데이터 저장하는 방법('이름','값')
        2. localStorage.getItem('key') --> 'value'를 가져온다 / 데이터를 가져오는 방법
        3. localStorage.removeItem('key') --> 데이터를 제거하는 방법 && 따로 수정하는 방법은 없고, 데이터를 가져와서 수정하고 다시 넣으면 된다.

    - local/sessionStorage에는 오직 문자만 저장가능하므로, array이나 object는 저장할수가 없다.

        1. 단, JSON.stringify()를 이용해서 저장할수 있다. (JSON.stringify)() --> string화 해서 만들어준다.)
            └-> localStorage.setItem('key', JSON.stringify('array/object'));
        2. 해당 데이터를 출력하더라도 JSON화 된 데이터로 나오므로, 다시 JSON.parse()를 이용해서 원래 array/object로 변경해서 출력하면 된다.
            └-> console.log(JSON.parse(localStorage.getItem('key')));



    
